import os
import subprocess
import time
import SCons.Errors

# Public version information
appName = 'NetMirage'
appVersionMajor = 0
appVersionMinor = 9
appVersionRevision = 0

# Set version based on whether we're using git or not
appVersion = '%d.%d.%d'%(appVersionMajor, appVersionMinor, appVersionRevision)
if os.path.isdir('../../.git'):
	try:
		commitId = subprocess.check_output(['git', 'log', '--format=%h', '-n 1']).strip()
		print 'Detected git install; using commit version'
		appVersion = '%s.%s'%(appVersion, commitId)
		
		dirtyRepo = subprocess.call(['git', 'diff-index', '--cached', 'HEAD', '--quiet'])
		if not dirtyRepo:
			dirtyRepo = subprocess.call(['git', 'diff-files', '--quiet'])
			if not dirtyRepo:
				dirtyRepo = subprocess.check_output(['git', 'ls-files', '--exclude-standard', '--others', '../..']).strip()
		if dirtyRepo:
			print 'Dirty git workspace; using timed version'
			appVersion = '%s.%d'%(appVersion, int(time.time()))
	except:
		pass
print 'Version:', appName, appVersion

# Locate sources
srcDir = Dir('.').srcnode().abspath

# Write version definitions
with open('%s/version.c'%srcDir, 'w') as verFile:
	verFile.write("""
		// This file was generated by SConstruct. DO NOT EDIT!
		#include "version.h"
		const char* getVersionString(void) { return "%s %s"; }
		uint16_t getVersionMajor(void) { return %d; }
		uint16_t getVersionMinor(void) { return %d; }
		uint16_t getVersionRevision(void) { return %d; }
	""" % (appName, appVersion, appVersionMajor, appVersionMinor, appVersionRevision))

Import('env')

# Resolve libxml dependency
try:
	libXmlVersion = subprocess.check_output(['xml2-config', '--version']).strip()
	libXmlFlags = subprocess.check_output(['xml2-config', '--cflags']).strip()
	libXmlLibs = subprocess.check_output(['xml2-config', '--libs']).strip()
except:
	raise SCons.Errors.UserError, 'Could not locate libxml install location. Ensure that libxml is installed and xml2-config is in the system path.'
print 'Using libxml %s [flags = %s] [libs = %s]'%(libXmlVersion, libXmlFlags, libXmlLibs)
env.Append(CFLAGS = libXmlFlags)
env.Append(LINKFLAGS = libXmlLibs)

# Resolve glib dependency
try:
	glibFlags = subprocess.check_output(['pkg-config', '--cflags', 'glib-2.0']).strip()
	glibLibs = subprocess.check_output(['pkg-config', '--libs', 'glib-2.0']).strip()
except:
	raise SCons.Errors.UserError, 'Could not locate GLib (GNOME Library) 2.0 install location. Ensure that glib is installed and visible to pkg-config.'
print 'Using glib 2.0 [flags = %s] [libs = %s]'%(glibFlags, glibLibs)
env.Append(CFLAGS = glibFlags)
env.Append(LINKFLAGS = glibLibs)

# Resolve libcap dependency
try:
	libCapFlags = subprocess.check_output(['pkg-config', '--cflags', 'libcap']).strip()
	libCapLibs = subprocess.check_output(['pkg-config', '--libs', 'libcap']).strip()
except:
	raise SCons.Errors.UserError, 'Could not locate libcap install location. Ensure that libcap is installed and visible to pkg-config.'
print 'Using libcap [flags = %s] [libs = %s]'%(libCapFlags, libCapLibs)
env.Append(CFLAGS = libCapFlags)
env.Append(LINKFLAGS = libCapLibs)

# Build the binaries
env.Append(CFLAGS = '-Wall -Wextra -Wundef -Wendif-labels -Wshadow -Wpointer-arith -Wbad-function-cast -Wcast-qual -Wcast-align -Wwrite-strings -Wconversion -Waggregate-return -Wstrict-prototypes -Wold-style-definition -Wmissing-prototypes -Wmissing-declarations -Wpacked -Wredundant-decls -Wnested-externs -Winline -Winvalid-pch -Wdisabled-optimization')
env.Append(CFLAGS = '-Wno-unused-parameter -Wno-missing-field-initializers')
env.Append(CFLAGS = '-Werror -fmax-errors=10 -std=c99')
env.Append(LINKFLAGS = '-lm')
Import('target')
app = env.Program(target, Glob('*.c'))

# Install binaries
env.Install('../../bin', app)
